<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js之数据类型引发的问题]]></title>
    <url>%2Fjs%E4%BF%AE%E4%BB%99%2Fjs%E4%B9%8B%E4%BC%A0%E5%8F%82%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[很多问题看似复杂，没有章法，事实上却有着千丝万缕的联系，陈道长此次阐述因为数据类型不同而引发的问题，本文主要探讨JS函数参数传递规则、浅拷贝、深拷贝的原理。收录在《齐云札记》 变量类型和存储首先要明确js中变量的特点，JS变量本身没有类型，只有值有类型。这句话怎么理解呢，先看下面这段代码。 12let a = 42typeof a //'number' 注意返回的是’number’，不是number，typeof检测的不是a的类型，而是42的类型，也就是a是没有类型的，只有a的值有类型。 JS总共有7种数据类型：Number、String、Boolean、Null、Symbol、Undefined、Object。Object是引用类型，其他的是基本类型。至于数组和函数属于Object的子类型。不过typeof 一个函数的时候 会返回’function’，这是为了彰显函数是一等公民的地位。它要特殊一点。 我们在声明一个变量时，会给变量进行赋值，变量在存储的时候也有区别。基本类型值存放在栈中，可以直接访问。引用类型值存放在堆内存中。很关键的一点：JS是不允许直接访问内存的，所以当一个变量的值是Object时，它保存的只是一个指针，指向的是Object存放的内存地址。 定义一个a 123456789101112131415## JS函数参数事实上，参数传递就是受到数据类型的影响。JS的函数有几个特性：1、参数没有个数限制，不管你函数里要用几个，它却可以接收任意多个，因为不用它操心，来的这么些参数都放到了一个参数数组里。另外参数值也没有类型限制，非常的开放，然后函数内再通过arguments对象去访问这个数组，拿到参数，所以参数不跟函数直接打交道，就好比中间有个传话的。**所以这也是为什么es6之前中不能直接给函数参数指定默认值**。es6新搞了个rest参数，它搭配了一个数组，变量多余的参数会存放到这个数组里，就不用arguments对象来获取了。```javascript// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 参数传递问题重点来了！函数参数传递其实就是把函数外的值复制给函数内部的值，也就是按照上面的规则来参数来自外部，要传递到函数里，找个中间变量，JS是参数是按“值”传递的，这个“值”就是变量的值。当变量的值属于基本类型，这个“值”就是普通值，当变量的值是引用类型时，这个“值”时引用类型的地址。传递的参数值是基本类型值会复制给一个局部变量。传递的参数是引用类型的值，复制的是地址。 深浅拷贝为啥存在浅拷贝和深拷贝，原因和上面一样。当我们想把对象a赋值给变量b，你会发现b和a指向的是一个地方。b改变的时候a也会变。这就是因为变量存储的只是个指针，引用类型的值是放在内存中，没法直接访问。 普通复制就是浅拷贝，新对象修改时，老对象也会发生变化。但是我们想把b复制给a后，然后两个对象互不干扰，完成这样的复制，这就是深拷贝。 深拷贝的原理就是把a对象的每个属性的值遍历一遍，然后把它复制给一个中间值，它作为普通的值进行复制到b对象的属性。这就回到了基本变量的复制问题。 当然一个对象的属性也可能是对象，例如：obj = [{a:1},{b:2}]，我们想把obj赋值给新对象，这个时候就得递归遍历了，把对象中a属性的值1和b属性的值2都给取到，然后把1和2再复制到新的对象里去，这个时候新对象就不会影响到之前的对象了。 说的有点绕，就是要切断新对象和老对象的关系，但是咱们又没办法直接操作内存，就只能通过引用取到老对象中存的数据值，拿出来之后放到新对象里。这就是深拷贝的思想。 总结由于js中数据类型不同，变量保存的值也有两种存储方式，在堆里面和在栈面，存储方式不同，也就导致了读取方式不同，也就导致了复制操作的结果不同，而参数传递和深浅拷贝都是数据复制的操作。所以两者受到的约束也是相同的，也就要遵循变量读取的规则。 本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。]]></content>
      <categories>
        <category>js修仙</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS修仙之一界本源]]></title>
    <url>%2Fjs%E4%BF%AE%E4%BB%99%2Fjs%E4%BF%AE%E4%BB%99%E4%B9%8B%E4%B8%80%E7%95%8C%E6%9C%AC%E6%BA%90%2F</url>
    <content type="text"><![CDATA[自计算机宇宙诞生以来，有很多大神通者在这里开天辟地，开创了很多界，有C、C++、Java等世界，它们彼此相连，其中有一处叫做JavaScript的世界，自被开辟以来吸引了很多修行者来此修炼。JS界由ES、DOM、BOM组成。话说这一日，齐云道长慕名来到JS界，刚入此界，便被界中三座大山吸引，分别名曰：作用域闭包、原型链继承、异步。相传此三山中藏着js界的创世本源。道长便在此闭关，静心感悟。 时间一晃就是数月，齐云早已把js界基本情况了解了，不过至于三座大山里隐藏的谜团却迟迟没有头绪。苦闷之中，坐在山上看日出日落，观星辰变化。斗转星移之间，齐云感慨万物变化奇妙，口中念起了老君的《道德经》：道生一，一生二，二生三，三生万物，万物负阴而抱阳。却突然露出了笑容：“怎么没早点想到呢，道衍万物。就是在主宇宙也是生于大道，更何况在这js世界呢”。 相传当年布兰登十天造此界，应该也是按照这个思路来的。万物都从无产生，此界也是无中生有，0和1是计算机宇宙中的阴阳，界中万物都是由此衍化。再定下八卦五行，此界便可运转繁衍不息。以往大部分人都是从基本的语法开始感悟，今天我从null开始推演。 了解宇宙本源之后，齐云此时心中有了明悟，仿佛看到了这个世界被创造和不断完善的样子。 虽然js经过几次的升级，拥有更强大的功能，不过最初js只是用来做简单的数据验证。。后来在ECMA-262中定义了ES，才提供了核心语言功能。 开天辟地是第一步，这个天地就叫引擎。最早只有创始人布兰登在网景时开辟的SpiderMonkey，之后诸神又开辟了几处不同的天地，JScript(IE6,IE7, IE8)、Chakra(IE9,IE10, IE11, IE Edge)、SpiderMonkey(Firefox)、JavaScriptCore(Safari)、V8(Chrome)。不同空间的环境略有不同，但js子民大多可以在这几处天地下都能生存，只不过生活节奏工作效率不一样（引擎性能不同）。更有平行天地Node等。天地既有了，便可以创造万物以及定下此界的规则。万物由代码组成，我们不可能一下子把万物都生成，只需要创造出最基本的元素和种类，之后让他们衍生万物。 组成代码的五行：变量、操作符、控制语句、对象、函数。变量：不给强制规定类型，可以说是世界最平等的事了，不管你本身什么类型，它都平等对待你，不过麻烦倒也很多。。函数：创造了不少默认的行为规则，toString()、get()、set()就好像人会吃饭睡觉的行为一样，被规定的。 这里只是化用五行，仅仅代表最基本的五种元素，并没有相生相克这些。 基本元素有了，怎么利用这些元素组成无数的代码，这些代码又如何丰富世界呢?只有道衍生的规则能办到，就好像四季更迭，花开花落一般。生与死，对与错。规则之一：语法。它规定了区分大小写、标识符、注释、严格模式、操作符、语句、对象的形式、函数定义。规则之二：数据类型和数据类型的转化，好比水变成冰规则之三：作用域，上下文，闭包。它描述变量存储的规律，细看js修仙之作用域闭包一文规则之四：原型链规则。它是JS界本源之一。有著名的this规则规则之五：异步规则。异步操作是为了改善单线程规则之等等：。。。还有很多规则，例如错误处理等。详看ECMAScript标准 借助八卦，将js中八种事物融合进来，相互配合，组成运转的JS界。乾代表引擎，坤代表回收机制，震代表构造函数，巽代表引用类型，坎代表执行语句，离代表编译器，艮代表异步，兑代表同步。 乾为天，坤为地，离为太阳，坎为月亮，四卦不停准转有了event loop，有了代码生成编译销毁，事件处理，好比四季循环。之后又有了了震雷，雷动生巽风，雷风相薄，构造函数和引用类型互相影响，艮山兑水，同步异步在event loop中在运转。 和其他OO世界一样，JS也是对象的世界。对象拥有着属性和方法。属性就是特征，方法就是行为。有了这些对象就能动起来了，仿佛拥有了生命一样。我们不可能一下子创造出所有的对象，只有先造出第一批对象，它们是JS对象老祖，负责繁衍教化万民。JS世界对象有自己的特点，它们当中有普通对象和函数对象。函数对象地位较高，属于一等公民，它们可以被调用，还修行一种独特的法术，叫做原型之体。原型之体与函数之体通过prototype和constructor相连。本体通过prototype可以获取原型之体的能力，原型之体则通过constructor表明自己函数之体的身份。 虽然typeof function a(){}返回的是’function’不是’object’,这是因为函数确实有一些特殊的属性，因此用typeof来区分函数和其他对象是有必要的 有人说JS中万物皆对象，事实上是错误的，因为(string、boolean、number、number、undefined)本身不是对象，而是基本类型如a=2。 在每个对象中都存在一块印记,叫[[prototype]]，它是对象的血脉之力，有着惊人的作用，当发动血脉之力时，可以发挥先祖之力，甚至可以使出先天对象的法术。有如此大的威力，主要因为对象的[[prototype]]印记连接的是父辈的原型之体！而父辈之体也有属于自己的血脉之力，因此后辈对象中有遇到自己解决不了的问题时，血脉之力会触发，帮助它们渡过难关。 有一个特殊的对象Object.prototype，它是这个世界所有对象的智慧之祖，所有的对象都继承了它的智慧。另一个重要的对象是Function.prototyp，它拥有了关于函数对象的智慧，并且它也继承了Object.prototype的智慧。这两个对象我称它们为先天对象，是JS根基对象，它们高高在上，是万象之根。而且它们是Object和Function对象的原型之体，神通广大，原型之体术就是它们最先练就。Function掌管着函数对象，Object掌管着原型之体和普通对象。几乎所有的函数都是引用类型Function的实例，几乎所有的对象都是Object的实例Function.prototype继承了Object.prototype（虽然会出现覆盖），Object的血脉又连接Function，可以说这两位是其他JS对象共同的老祖。 12Function.prototype.__prototype === Object.prototypeObject.__prototype === Function.prototype 在某对象中找不到要找的属性时，就会沿着原型链网上找。从ECMAScript6开始，[[Prototype]]可以通过Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问，这个等同于JS的非标准但许多浏览器实现的属性proto 全局的Function对象没有自己的属性和方法，继承于Function.prototype，因此Function.prototype是不能被修改的。Function.prototype还有个特殊的身份，它也是个函数，简直是深藏不露。 12console.log(Function.prototype)[Function] 剩下的一些对象组成了长老会，它们分别是Array、Date、RegExp、String、Math、Error等，以及后面加入的Set、Map等几位长老。长老们拥有各自的神通和家族。例如Array长老擅长操作数组，有sort、slice等神通，而Math长老有random神通。不过它们也都是Object和Fucntion的部下。每个长老的函数之体源自Function，继承了Function.prototype的神通。而它们的原型之体继承了Object.prototype的智慧。 对象是引用类型的实例，通过new加构造函数可以创造新对象，后来先天对象Object又感悟了Object.create之法，也可以创造新的对象。 事实上，根本没有构造函数，或者人人都是构造函数。当且仅当使用new时，函数调用会变成构造函数调用。 JS界的老祖，长老会及长老会门下关系如下: 可以看到两位老祖高高在上，受万众仰视。它们与多位长老一样，函数体通过蓝色箭头prototype指向原型之体。原型之体通过灰色线constructor连接函数之体,后代子孙而血脉之力由[[prototype]]沿着橙色线，找到了父对象（构造函数）的原型之体，父对象或长老们的原型之体的血脉是绿色的线，指向了Object.prototype。 12345duke.__proto__ === Sub.prototypeSub.prototype.__proto__ = == Object.prototype-------------------------------------------------Sub.__proto__ === Function.prototypeFunction.prototype.__proto__ === Object.prototype 至此，我们可以这么归纳：1.所有对象都有隐式原型[[prototype]]，它指向了创造它的构造函数的原型对象，一直连接到Object.prototype,而Object.prototype也有隐式原型，而它指向Null，当访问一个对象的属性找不到时，会沿原型链向上找，找到了会返回，找不到就会继续向上知道null会返回undefined。 2.几乎所有函数都是Function的实例，为了符合这个规则，Function的隐式原型指向的是它的原型对象。 易是包罗万象，一切事物和现象都可以装进这个模式里，易是变化的，不管代码如何复杂，都是符合最基本的规则，易虽然变化，但大道是永恒的，变化之道是不变的。JS的世界也是这样，不管由多复杂的代码组成的程序，也都得遵循最基本的变量声明语法，也要符合原型的设计模式，也都得按照既定的规则来编写。所以，明白这个JS界的一界本源，才能在这里畅游天地之间。 本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。]]></content>
      <categories>
        <category>js修仙</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之对象属性]]></title>
    <url>%2Fjs%E4%BF%AE%E4%BB%99%2Fjs%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[在js属性描述符这部分有几个较难理解的名词概念，本文旨在描述自己对它们的理解，并收录在《齐云札记》里，主要包括:[[Get]]/[[Put]]、get/set、getter/setter几个概念的阐述，数据属性和访问器属性。 属性首先我们要搞清楚属性的概念，属性是存储在特定命名位置的值，是对象的内容，属性并不直接存储在对象容器内部。属性有两种类型:数据属性和访问器属性。属性具备了属性描述符，用来描述属性拥有的特性。 属性描述符属性描述符用来描述属性特性的(只有在内部才能用的特性),配置属性是否可读，是否可写，是否可枚举，值是多少，读写。 属性描述符对象Object.definePrOperty(obj,’a’,{value:2,writable:true,configurable:true})第三个参数就是属性描述符对象 ，首先它是个对象，它有自己的属性，其次它是属性a的属性描述符，用来配置属性。 定义这些特性为了实现JavaScript引擎用的，因此再JavaScript中不能直接访问它们。为了表示特征是内部值，ES规范把它们放在了两对方括号中，例如[[Enumerable]]。 访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。共有四个描述其行为的特征: [[Configurable]]：配置，表示能否删除修改属性的特性，或者把属性修改为访问器属性。默认true [[Enumerable]]：枚举，表示能否通过for-in循环返回属性。默认true [[Writable]]：可写，表示能否修改属性值。默认true [[Value]]：属性的数据值。读写属性值从该位置。默认undefined 访问器属性访问器属性不包含数据值；它们包含一对getter和setter函数。共有四个描述其行为的特征: [[Configurable]]：配置，表示能否删除修改属性的特性，或者把属性修改为访问器属性。默认true [[Enumerable]]：枚举，表示能否通过for-in循环返回属性。默认true [[Get]]：在读取属性值时调用的函数。默认undefined [[Set]]：在写入属性值时调用的函数。默认undefined ==当个一个属性定义getter、setter或者两者都有时，这个属性就成了访问器属性== 知道属性分类之后，下面我们逐一解答开头的几个问题： [[Get]]/[[Put]]是什么首先要明确一点，[[Get]]和[[Put]]是对象默认的内置操作，可以理解为算法函数。它是在访问属性时的操作，例如通过obj.a访问a属性时就是实现了[[Get]]操作，它会先找到相同的属性名，找到才要返回属性值。没有找到就会按照[[Get]]算法的设计，沿着原型链找，找不到会返回undefined。[[Put]]被触发时，取决于许多因素，最重要的有对象中是否已经存在这个属性。如果已经存在，算法大致会检查下面这些内容： 1.属性是否是访问描述符？如果是并且存在setter就调用setter2.属性的数据描述符中writable是否是false？如果是，在非严格模式下静默失败，在严格模式下抛出TypeError异常。3.如果都不是，将该值设置为属性的值。 get/set和getter/setter[[Get]]和[[Set]]：当属性拥有这两个特性时，属性就是访问器属性。代表着在访问属性或者写入属性值时，对返回值做附加的操作。而这个操作就是getter/setter函数。它们只能应用到单个属性上，无法应用在整个对象上。getter/setter是隐藏函数，是访问器属性默认拥有的隐藏函数。在读取访问器属性时调用getter，返回有效的值；在写入访问器属性时调用setter函数并传入新值。 不管是对象文字语法中的get a(){…}，还是的defineProperty(..)中的显式定义，二者都会在对象中创造一个不包含值得属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当做属性访问的返回值： 123456789101112var myObject = &#123;//给a定义一个getter get a()&#123; return this._a_; &#125;,//给a定义一个setter set a(val)&#123; this._a_=val *2; &#125;&#125;myObject.a=2;myObject.a;//4 ==设置getter会覆盖默认的[[Get]]操作，setter会覆盖默认得[[Put]],也被称为赋值操作== 实际上我们赋值([[Put]])操作中的值2存储到了另一个变量_a_中。名称_a_只是一种惯例，没有任何特殊行为。 总结属性是拥有自己的特性的，主要用来描述属性是否可以进行修改枚举配置的。我们访问对象的属性时就是[[Get]]操作，写入就是[[Put]]，根据算法找到对应的属性。如果要对属性值进行附加操作时，就需要设置get/set特性，此时属性也就会变成访问器属性，然后调用默认的隐藏的getter/setter函数对属性进行操作。然后返回属性值。 本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。]]></content>
      <categories>
        <category>js修仙</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue之electron打包]]></title>
    <url>%2Fvue%2Fvue%E4%B9%8Belectron%2F</url>
    <content type="text"><![CDATA[本文记录了使用electron-vue对vue项目进行打包的处理办法。工欲善其事,必先利其器,在使用electron-vue打包客户端之前,我们需要进行相关的环境配置。 环境配置需要管理员权限的powershell,外加翻墙,否则很多下载都不成功,关掉杀毒软件 安装node,vue-cli 安装windows-build-tools 1npm install --global --production windows-build-tools 构建项目1vue init simulatedgreg/electron-vue my-project 在项目初始化过程中会让选择electron-builder或者electron-packager,这是electron打包的两种方式。下面我们会分别介绍两种方式异同。 再生成的项目中\src下有main和renderer,其中main为主进程,配置菜单界面大小等,renderer为渲染进程,页面组件在这里配置 结构图如下：无论是选择的packager,还是builder,在生成项目之后,都要执行以下操作: 123cd projectnpm installnpm run dev electron-builder打包过程1npm run build 执行该命令后会下载打包所需要的依赖文件,例如electron-vX.X.X-win32-x64.zip,但通常会出现下载失败,我们可以手动下载,放到指定的目录下。 解决办法就是根据控制台显示的错误信息,到npm去搜索该文件,下载下来。通常放在C:\Users\Administrator\AppData\Local\electron\Cache 解决了出现的问题之后继续执行npm run build,如果继续出现错误,仍然按照上述办法解决。另外有两个必装的依赖:winCodeSign和nsis wincodesin包地址nsis包地址 将下载的依赖解压到C:\Users\Administrator\AppData\Local\electron\Cache 之后就可以顺利打包了 electron-packer打包过程使用packager打包只能生成可执行版,通过下面指令生成相对的客户端。 1234npm run build:win32npm run build:darwinnpm run build:linuxnpm run build:mas 本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
</search>
