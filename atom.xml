<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>齐云札记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chenshaotang.com/"/>
  <updated>2019-01-12T11:04:56.292Z</updated>
  <id>https://chenshaotang.com/</id>
  
  <author>
    <name>陈少棠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js之对象属性</title>
    <link href="https://chenshaotang.com/js%E9%9A%BE%E7%82%B9/js%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7/"/>
    <id>https://chenshaotang.com/js难点/js之对象属性/</id>
    <published>2019-01-10T15:47:32.000Z</published>
    <updated>2019-01-12T11:04:56.292Z</updated>
    
    <content type="html"><![CDATA[<p>在js属性描述符这部分有几个较难理解的名词概念，本文旨在描述自己对它们的理解，主要包括:[[Get]]/[[Put]]、get/set、getter/setter几个概念的阐述，数据属性和访问器属性。<br><a id="more"></a></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>首先我们要搞清楚属性的概念，属性是存储在特定命名位置的值，是对象的内容，属性并不直接存储在对象容器内部。属性有两种类型:数据属性和访问器属性。属性具备了属性描述符，用来描述属性拥有的特性。</p><h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>属性描述符用来描述属性特性的(只有在内部才能用的特性),配置属性是否可读，是否可写，是否可枚举，值是多少，读写。</p><p><strong>属性描述符对象</strong>：Object.definePrOperty(obj,’a’,{value:2,writable:true,configurable:true})第三个参数就是属性描述符对象 ，首先它是个对象，它有自己的属性，其次它是属性a的属性描述符，用来配置属性。</p><p>定义这些特性为了实现JavaScript引擎用的，因此再JavaScript中不能直接访问它们。为了表示特征是内部值，ES规范把它们放在了两对方括号中，例如[[Enumerable]]。</p><blockquote><p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p></blockquote><h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。共有四个描述其行为的特征:</p><ul><li>[[Configurable]]：配置，表示能否删除修改属性的特性，或者把属性修改为访问器属性。默认true</li><li>[[Enumerable]]：枚举，表示能否通过for-in循环返回属性。默认true</li><li>[[Writable]]：可写，表示能否修改属性值。默认true</li><li>[[Value]]：属性的数据值。读写属性值从该位置。默认undefined</li></ul><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>访问器属性不包含数据值；它们包含一对getter和setter函数。共有四个描述其行为的特征:</p><ul><li>[[Configurable]]：配置，表示能否删除修改属性的特性，或者把属性修改为访问器属性。默认true</li><li>[[Enumerable]]：枚举，表示能否通过for-in循环返回属性。默认true</li><li>[[Get]]：在读取属性值时调用的函数。默认undefined</li><li>[[Set]]：在写入属性值时调用的函数。默认undefined</li></ul><p><strong>当个一个属性定义getter、setter或者两者都有时，这个属性就成了访问器属性。</strong></p><p>知道属性分类之后，下面我们逐一解答开头的几个问题：</p><h1 id="Get-Put-是什么"><a href="#Get-Put-是什么" class="headerlink" title="[[Get]]/[[Put]]是什么"></a>[[Get]]/[[Put]]是什么</h1><p>首先要明确一点，[[Get]]和[[Put]]是对象默认的内置操作，可以理解为算法函数。它是在访问属性时的操作，例如通过obj.a访问a属性时就是实现了[[Get]]操作，它会先找到相同的属性名，找到才要返回属性值。<br>没有找到就会按照[[Get]]算法的设计，沿着原型链找，找不到会返回undefined。<br>[[Put]]被触发时，取决于许多因素，最重要的有对象中是否已经存在这个属性。如果已经存在，算法大致会检查下面这些内容：</p><p>1.属性是否是访问描述符？如果是并且存在setter就调用setter<br>2.属性的数据描述符中writable是否是false？如果是，在非严格模式下静默失败，在严格模式下抛出TypeError异常。<br>3.如果都不是，将该值设置为属性的值。</p><h1 id="get-set和getter-setter"><a href="#get-set和getter-setter" class="headerlink" title="get/set和getter/setter"></a>get/set和getter/setter</h1><p>[[Get]]和[[Set]]：当属性拥有这两个特性时，属性就是访问器属性。代表着在访问属性或者写入属性值时，对返回值做附加的操作。而这个<strong>操作就是getter/setter函数</strong>。<br>它们只能应用到单个属性上，无法应用在整个对象上。getter/setter是隐藏函数，是访问器属性默认拥有的隐藏函数。在读取访问器属性时调用getter，返回有效的值；在写入访问器属性时调用setter函数并传入新值。</p><p>不管是对象文字语法中的get a(){…}，还是的defineProperty(..)中的显式定义，二者都会在对象中创造一个不包含值得属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当做属性访问的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="comment">//给a定义一个getter</span></span><br><span class="line">get a()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//给a定义一个setter</span></span><br><span class="line">set a(val)&#123;</span><br><span class="line"><span class="keyword">this</span>._a_=val *<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.a=<span class="number">2</span>;</span><br><span class="line">myObject.a;<span class="comment">//4</span></span><br></pre></td></tr></table></figure><p><strong>设置getter会覆盖默认的[[Get]]操作，setter会覆盖默认得[[Put]],也被称为赋值操作</strong></p><blockquote><p>实际上我们赋值([[Put]])操作中的值2存储到了另一个变量_a_中。名称_a_只是一种惯例，没有任何特殊行为。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>属性是拥有自己的特性的，主要用来描述属性是否可以进行修改枚举配置的。我们访问对象的属性时就是[[Get]]操作，写入就是[[Put]]，根据算法找到<br>对应的属性。如果要对属性值进行附加操作时，就需要设置get/set特性，此时属性也就会变成访问器属性，然后调用默认的隐藏的getter/setter函数对属性<br>进行操作。然后返回属性值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在js属性描述符这部分有几个较难理解的名词概念，本文旨在描述自己对它们的理解，主要包括:[[Get]]/[[Put]]、get/set、getter/setter几个概念的阐述，数据属性和访问器属性。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js难点" scheme="https://chenshaotang.com/categories/js%E9%9A%BE%E7%82%B9/"/>
    
    
      <category term="js" scheme="https://chenshaotang.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>记录electron-vue打包</title>
    <link href="https://chenshaotang.com/vue/electron-vue/"/>
    <id>https://chenshaotang.com/vue/electron-vue/</id>
    <published>2018-12-29T06:06:53.000Z</published>
    <updated>2019-01-12T03:50:58.962Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了使用electron-vue对vue项目进行打包的处理办法。工欲善其事,必先利其器,在使用electron-vue打包客户端之前,我们需要进行相关的环境配置。<br><a id="more"></a></p><p>##环境配置<br>需要管理员权限的powershell,外加翻墙,否则很多下载都不成功,关掉杀毒软件</p><ul><li>安装node,vue-cli</li><li>安装windows-build-tools</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init simulatedgreg/electron-vue my-project</span><br></pre></td></tr></table></figure><p>在项目初始化过程中会让选择electron-builder或者electron-packager,这是electron打包的两种方式。下面我们会分别介绍两种方式异同。</p><blockquote><p>再生成的项目中\src下有main和renderer,其中main为主进程,配置菜单界面大小等,renderer为渲染进程,页面组件在这里配置</p></blockquote><p>结构图如下：<br><img src="/vue/electron-vue/jie.jpg" alt=""><br>无论是选择的packager,还是builder,在生成项目之后,都要执行以下操作:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> project</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p><h2 id="electron-builder打包过程"><a href="#electron-builder打包过程" class="headerlink" title="electron-builder打包过程"></a>electron-builder打包过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>执行该命令后会下载打包所需要的依赖文件,例如electron-vX.X.X-win32-x64.zip,但通常会出现下载失败,我们可以手动下载,放到指定的目录下。</p><blockquote><p>解决办法就是根据控制台显示的错误信息,到npm去搜索该文件,下载下来。通常放在C:\Users\Administrator\AppData\Local\electron\Cache</p></blockquote><p>解决了出现的问题之后继续执行npm run build,如果继续出现错误,仍然按照上述办法解决。<br>另外有两个必装的依赖:winCodeSign和nsis</p><blockquote><p><a href="https://github.com/electron-userland/electron-builder-binaries/releases" target="_blank" rel="noopener">wincodesin包地址</a><br><a href="https://github.com/electron-userland/electron-builder-binaries/releases/tag/nsis-resources-3.0.0" target="_blank" rel="noopener">nsis包地址</a></p></blockquote><p>将下载的依赖解压到C:\Users\Administrator\AppData\Local\electron\Cache</p><p>之后就可以顺利打包了</p><h2 id="electron-packer打包过程"><a href="#electron-packer打包过程" class="headerlink" title="electron-packer打包过程"></a>electron-packer打包过程</h2><p>使用packager打包只能生成可执行版,通过下面指令生成相对的客户端。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm run build:win32</span><br><span class="line">npm run build:darwin</span><br><span class="line">npm run build:linux</span><br><span class="line">npm run build:mas</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了使用electron-vue对vue项目进行打包的处理办法。工欲善其事,必先利其器,在使用electron-vue打包客户端之前,我们需要进行相关的环境配置。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="https://chenshaotang.com/categories/vue/"/>
    
    
      <category term="electron" scheme="https://chenshaotang.com/tags/electron/"/>
    
  </entry>
  
</feed>
