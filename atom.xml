<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>齐云札记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chenshaotang.com/"/>
  <updated>2019-01-26T13:37:02.733Z</updated>
  <id>https://chenshaotang.com/</id>
  
  <author>
    <name>陈少棠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js之闭包是如何产生的？</title>
    <link href="https://chenshaotang.com/js%E4%BF%AE%E4%BB%99/js%E4%B9%8B%E9%97%AD%E5%8C%85%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B8%8B/"/>
    <id>https://chenshaotang.com/js修仙/js之闭包三部曲下/</id>
    <published>2019-01-25T10:49:58.000Z</published>
    <updated>2019-01-26T13:37:02.733Z</updated>
    
    <content type="html"><![CDATA[<p>在前两篇文章中，齐云道长介绍了作用域和执行上下文，也包括了变量对象、作用域链、变量提升的原理。为的就是在这里说出这句话——<strong>当代码写下的那一刻就注定了闭包的出现</strong>，这就是事物发展的规律。<br><a id="more"></a></p><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>不少朋友搞不清闭包是什么，甚至和立即执行函数混淆，也有些朋友认为闭包就是一种特殊的函数，不过显然这么说是不准确的。闭包不是一种函数，而是一种现象:<br>闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。</p><p>我们知道词法作用域是代码写下的时候就形成了，执行环境是在函数调用的时候生成，在代码执行完从执行环境栈中出栈回收，再配合着JS代码是顺序执行的</p><h2 id="闭包是如何产生的"><a href="#闭包是如何产生的" class="headerlink" title="闭包是如何产生的"></a>闭包是如何产生的</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = fun()</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>在创建函数的时候，产生相应的执行环境，在执行环境里生成活动对象、作用域链。先利用作用域进行变量提升，然后顺序执行的时候，对变量进行赋值操作，执行完毕把执行环境从执行环境栈中弹出。</p><p>fun()创建了自己的执行环境，里面有活动对象，进行了变量提升，执行完本来应该被弹出。然而返回的foo函数被赋值给bar，<strong>foo函数和fun函数的变量对象，组成了闭包</strong>。</p><p>foo函数里要使用变量a，但是foo的执行环境里的并没有声明a，此时会沿着执行环境里的作用域链搜寻a的声明，<strong>由于foo包含着对fun的活动对象的引用，所以fun的活动对象一直没有被释放。这就是产生闭包的原因</strong>。</p><blockquote><p>作用域链的值赋给了执行环境内部的[[Scope]]属性，作用域链是数组形式，scope[0]是当前活动对象，scope[1]是外部函数的活动对象，……scope[leght-1]是全局变量对象。</p></blockquote><p>所以，什么是闭包？<br>当某个函数的作用域链还引用着其他函数的活动对象时，就会形成闭包。</p><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>es6出现之前，有个非常经典的问题——循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个经典的问题是由于es6之前并没有块级作用域，所以i是全局变量，然后setTimeout的回掉又是在循环结束才会执行，所以最终会每秒一次输出5，总共输出5次，而不是从1-5。</p><p>我们通过闭包解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;,j*<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过立即执行函数，形成闭包，这样每次循环都会创建一个独立的执行环境，最终实现效果。</p><blockquote><p>当然es6之后，我们可以用let替代var，因为let可以生成块作用域。</p></blockquote><p>闭包另一个重要的作用是模块化，可以实现对私有变量的封装。</p><p>本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前两篇文章中，齐云道长介绍了作用域和执行上下文，也包括了变量对象、作用域链、变量提升的原理。为的就是在这里说出这句话——&lt;strong&gt;当代码写下的那一刻就注定了闭包的出现&lt;/strong&gt;，这就是事物发展的规律。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js修仙" scheme="https://chenshaotang.com/categories/js%E4%BF%AE%E4%BB%99/"/>
    
    
      <category term="js" scheme="https://chenshaotang.com/tags/js/"/>
    
      <category term="闭包" scheme="https://chenshaotang.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>js之执行上下文是什么？</title>
    <link href="https://chenshaotang.com/js%E4%BF%AE%E4%BB%99/js%E4%B9%8B%E9%97%AD%E5%8C%85%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://chenshaotang.com/js修仙/js之闭包三部曲中执行上下文/</id>
    <published>2019-01-21T07:27:06.000Z</published>
    <updated>2019-01-26T13:48:41.154Z</updated>
    
    <content type="html"><![CDATA[<p>作为闭包三部曲第二部，本文是承上启下的一篇，主要讲解执行上下文环境、环境栈、作用域链的相关概念。<br><a id="more"></a></p><h2 id="执行上下文是什么"><a href="#执行上下文是什么" class="headerlink" title="执行上下文是什么"></a>执行上下文是什么</h2><p>执行上下文(execution context)，也叫做执行环境，是JS代码执行过程中一个至关重要的环节。context是语境，上下文，环境，背景的意思，这就很明显很直白了，所谓执行环境和咱们平时讲的学习环境、工作环境是一个意思。任何事物都离不开环境，自然环境也是环境，产品离不开车间环境，代码也在环境里才能被执行，它是为了代码能被执行而创造的，执行环境里面主要包含了变量对象、作用域链、this。</p><p>执行环境不是先天就有的，而是为了执行代码才特地创造符合执行这段代码的一个环境，就好像我为了种一朵花，而搞了个温室大棚一样。</p><h3 id="执行环境的生命周期"><a href="#执行环境的生命周期" class="headerlink" title="执行环境的生命周期"></a>执行环境的生命周期</h3><p>在js之作用域篇中，我们举例用医院动手术的来比喻作用域是什么，事实上执行上下文也蕴含在其中。</p><p>为了给病人做手术，院方(浏览器、node)创造了一个无菌手术室(全局环境)，然后为了完成手术，与这个手术相关的所有器材药物医务人员都安排好(变量对象)，进行麻醉、开刀、缝合等手术(函数)，每个子手术也都要在相应的区域内完成(函数执行环境)，在这些区域内，有相应的器材药物医务人员(活动对象)。这在手术室里一步步完成，最终完成手术，然后病人离开手术室(执行环境栈)。</p><p>全局变量环境始终存在的。<br>函数执行环境主要经历了几个阶段：</p><ol><li>在创建函数时，会创建相应的执行环境</li><li>创建变量对象/活动对象</li><li>创建作用域链、赋值this</li><li>函数被调用，执行环境会把压入栈中</li><li>代码在执行环境在被执行</li><li>执行环境从执行环境栈出栈，被回收</li></ol><h2 id="变量对象-活动对象"><a href="#变量对象-活动对象" class="headerlink" title="变量对象/活动对象"></a>变量对象/活动对象</h2><p>变量对象是执行环境里的一个特殊对象，它包含了所有变量和函数。<strong>可以把它看作是函数执行前的预处理</strong>。</p><p><strong>函数才有活动对象，当执行环境是函数时，活动对象被当作变量环境</strong>。它包含arguments、this和其他命名参数的值。arguments只有函数的执行环境才有，this也只能在函数内部使用。</p><h3 id="变量提升的本质"><a href="#变量提升的本质" class="headerlink" title="变量提升的本质"></a>变量提升的本质</h3><ol><li>它在创建时只有一个arguments，然后开始通过<strong>作用域规则</strong>检测作用域内所有变量和函数的声明。</li><li>找到函数的声明时，会在变量对象创建属性，属性名就是该函数名，属性值是指针，指向函数的内存地址。</li><li>检测变量声明，找到之后同样会创建属性，属性名是变量名，属性被赋undefined</li></ol><p>所以变量提升的本质就在这，变量对象创建时，会检测函数和变量声明，将变量和函数声明变成<strong>变量对象的属性</strong>，并且将变量声明赋值为undefined，函数的是地址。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链形式上是个数组，本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p><p>每个执行环境都有属于自己的作用域链。</p><p>作用域链的值赋给了执行环境内部的[[Scope]]属性，作用域链是数组形式，scope[0]是当前活动对象，scope[1]是外部函数的活动对象，……scope[leght-1]是全局变量对象。</p><p>所以可以通过作用域链找到其他作用域的变量，这就是作用域链的原理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面讲到，当为了程序能够顺利执行而专门创造了一个舒适的环境（执行环境），在这个环境里，又创造了一个变量对象，作用域链和this。<br>有没有发现作用域是访问变量的规则，而变量对象也包含了变量函数声明，那他们是一回事嘛？作用域和变量对象什么区别？</p><p>在作用域一文中，介绍了作用域的两个作用，</p><ul><li>一个是在编译过程中，引擎会查询看作用域中有没有某个变量，没有的话要声明，有的话就跳过。</li><li>另一个作用是在程序执行时，引擎会通过作用域找到某个变量，然后进行赋值等操作。</li></ul><p><strong>变量对象是程序执行的预处理</strong>，变量对象里会对变量声明进行提升和赋值undefined。</p><p>变量对象和作用域并不是一个东西，另外两点。</p><ol><li><strong>作用域是在代码写下来就产生了，执行环境在代码执行时才被创建，作用域链是在执行环境里才被创建</strong>。</li><li>执行环境在代码执行完了之后被清除。</li></ol><p>本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为闭包三部曲第二部，本文是承上启下的一篇，主要讲解执行上下文环境、环境栈、作用域链的相关概念。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js修仙" scheme="https://chenshaotang.com/categories/js%E4%BF%AE%E4%BB%99/"/>
    
    
      <category term="js" scheme="https://chenshaotang.com/tags/js/"/>
    
      <category term="闭包" scheme="https://chenshaotang.com/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="执行上下文" scheme="https://chenshaotang.com/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>JS之如何理解作用域的概念</title>
    <link href="https://chenshaotang.com/js%E4%BF%AE%E4%BB%99/js%E4%B9%8B%E9%97%AD%E5%8C%85%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B8%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/"/>
    <id>https://chenshaotang.com/js修仙/js之闭包三部曲上作用域规则/</id>
    <published>2019-01-19T01:09:14.000Z</published>
    <updated>2019-01-26T13:36:28.678Z</updated>
    
    <content type="html"><![CDATA[<p>JS世界中，有种奇特的规则叫做闭包，它总是披着一层面纱，让人看不清真面目。然而讲闭包时，往往都会和作用域联系到一起，原因很简单，闭包的出现就是受到作用域规则的影响，可以说是因果关系。齐云道长把闭包的前世今生用上中下三部曲来讲述。本期是上部，讲述闭包诞生的前因——作用域。<br><a id="more"></a></p><h2 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h2><p>这一段“js语言”描述的话语，很明确的说明了JS中作用域主要是做什么的。但可能还是很抽象。为了大家更好理解，下面我用现实中的事物来类比作用域的概念，也为了后面两篇文章铺垫。</p><p>有一位病人，去医院做手术，到了医院先挂号缴费，然后申报了手术日期，等待手术。到了手术那天，手术室里有专家医生、几位护士、麻醉科的医生、还有<br>一些医疗设备、鲜血手术必需品。</p><p>上面是一位病人在医院看病的情况，事实上这里包含了作用域的相关概念。</p><ul><li>作用域：就是医院的医疗资源。包含了医生护士、医疗设备、药物等。</li><li>全局作用域：比如手术要准备的血库、药物、器械等。</li><li>函数：比作动手术，手术中又包含了许多小手术，比如麻醉、开刀、缝合等。大手术中包含着很多小手术就是函数嵌套。</li><li>函数作用域：自然就是在每个手术中可以用到的资源。</li><li>变量提升：任何一次手术，都需要提前申请手术室，根据病人情况，填写手术计划，需要的资源清单。手术之前把这些弄好，把设备调整好，把工具药物准备好。这就是变量提升。</li><li>作用域链： 当医生在进行缝合时需要输血，计划内的血用光了，就需要从库存里调用。这就是作用域链。</li></ul><p>当然这个例子也不完全贴切，只是为了简单形象的描述作用域的工作方式。</p><h2 id="作用域的作用"><a href="#作用域的作用" class="headerlink" title="作用域的作用"></a>作用域的作用</h2><p><code>var a=4</code>,这是一个变量赋值操作，执行之前，代码都要先被编译器进行解析，编译之后的代码才能被引擎执行，而这两者都离不开作用域。编译时，<strong>编译器会询问作用域里是否已经存在该变量声明</strong>，有的话继续编译，没有就会在里面声明<code>var a</code>。引擎会在执行时，会<strong>先在作用域找该变量声明</strong>，存在就会完成赋值操作<code>a=4</code>，不存在就会沿着作用域链找。</p><p>作用域(scope)，首先它是个范围，是变量能够被访问，能够起作用的范围，函数可以访问外部的变量，外部不能访问函数内部的<br>js中的作用域的工作方式通常指的是词法作用域，这句话意思就是<strong>作用域在写代码的时候就确定了</strong>。</p><h2 id="变量提升规则"><a href="#变量提升规则" class="headerlink" title="变量提升规则"></a>变量提升规则</h2><p>理解了作用域是什么之后，讲一下作用域里的一个特性——变量提升，它是受到<strong>编译器</strong>的影响。代码执行前，编译器会先将变量声明提升到作用域的顶部，而变量赋值和逻辑操作则会留在原处，等待被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> 手术室预约 = 某天;</span><br><span class="line"><span class="keyword">var</span> 器材 = [<span class="string">'刀子'</span>,<span class="string">'持针钳'</span>，<span class="string">'止血钳'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> 手术(<span class="params">患者</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> 计划的输血量 = XX ML</span><br><span class="line">    开刀()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> 开刀(<span class="params"></span>)</span>&#123;</span><br><span class="line">        需要刀子;</span><br><span class="line">        需要止血钳</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> 缝合 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        需要持针钳;</span><br><span class="line">        需要输血;</span><br><span class="line">        需要额外的血;</span><br><span class="line">    &#125;</span><br><span class="line">    缝合();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> 额外的血 = xxx ML</span><br><span class="line"><span class="function"><span class="keyword">function</span> 手术(<span class="params"></span>)</span></span><br></pre></td></tr></table></figure><p>事实上代码是这么执行的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> 手术(<span class="params">患者</span>)</span>&#123; <span class="comment">//①先根据患者情况，制定手术计划</span></span><br><span class="line">    <span class="keyword">var</span> 计划的输血量;  <span class="comment">//手术细节，</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> 开刀(<span class="params"></span>)</span>&#123;  <span class="comment">//开刀的计划</span></span><br><span class="line">        需要刀子;</span><br><span class="line">        需要止血钳;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> 缝合;  <span class="comment">//然后是缝合</span></span><br><span class="line">    <span class="comment">//下面是具体实施细节</span></span><br><span class="line">    计划的输血量 = XX ML;</span><br><span class="line">    开刀();</span><br><span class="line">    缝合 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        需要持针钳;</span><br><span class="line">        需要输血;</span><br><span class="line">        需要额外的血;</span><br><span class="line">    &#125;</span><br><span class="line">    缝合();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> 手术室预约;   <span class="comment">//计划提交要申请手术室</span></span><br><span class="line"><span class="keyword">var</span> 器材 ;       <span class="comment">//申请器材</span></span><br><span class="line"><span class="keyword">var</span> 额外的血 ;</span><br><span class="line"></span><br><span class="line"> 手术室预约 = 某天 ;   <span class="comment">//手术日子到了</span></span><br><span class="line"> 器材 = [<span class="string">'刀子'</span>,<span class="string">'持针钳'</span>，<span class="string">'止血钳'</span>] ;  <span class="comment">//器材准备好了</span></span><br><span class="line"> 额外的血 = xxx ML;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> 手术(<span class="params"></span>);   //进行手术</span></span><br></pre></td></tr></table></figure><p>上面这些混杂代码，描述了手术的过程。当然也是变量提升的过程，变量在声明的时候会被提升到所在作用域的顶端。<strong>函数声明优先级是最高的</strong>。之后才是变量声明。<br>变量提升是JS的一个特性了，但是也带来了不少问题，再加上在es6之前没有块级作用域，内层变量有时候会因为提升覆盖掉外面的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>本来想着<code>console.log</code>的是全局变量的3，实际上由于变量提升，内部的变量声明提升到函数作用域顶部，变成了<code>var a; console.log(a)</code>，所以才会是undefined。</p><h2 id="块作用域规则"><a href="#块作用域规则" class="headerlink" title="块作用域规则"></a>块作用域规则</h2><p>es6提出了let、const、块级作用域，因此作用域规则也随着发生了改变。之前js只有全局作用域和函数作用域，但是显然会有很多问题，比如在<code>for(var i=0;i&lt;5;i++){console.log(i)}</code>中，i会被绑定到外部作用域，造成全局变量污染，另外会造成对外部变量的覆盖。<br>块级作用域正是为了解决这些问题，将代码封装在里面。这也使得es5中立即执行函数有了替代。es6块级作用域可以嵌套，也可以声明函数。外层作用域无法读取内层。</p><h2 id="let、const规则"><a href="#let、const规则" class="headerlink" title="let、const规则"></a>let、const规则</h2><p>let和const用来声明变量，使用let的时候，let会创造一个块作用域，声明的变量只在作用域中有效。在上面for循环问题中，let就可以完美解决var提升的问题。<br>let有以下他几个规则：<br>1、创造块级作用域，变量在块级作用域才有用<br>2、不允许重复声明</p><p>const大体和let相似，但是有个特点，<strong>const声明的是常量</strong>，变量的值不能重新赋值。</p><p>关于变量提升，let和const是不允许提升的，事实上，let和const下变量也是有提升的，只不过调用变量之前没声明这个变量会报错，所以只能老老实实的在调用前声明。在块级作用域下声明的函数也会被提升。</p><p>本文结合了es5和es6中和作用域有关系的相关概念，阐述了作用域在js中主要作用，当然作用域链并没有讲，因为需要把作用域链放在上下文环境一起讲，详情请看下一期。js闭包三部曲第二部，</p><p>本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS世界中，有种奇特的规则叫做闭包，它总是披着一层面纱，让人看不清真面目。然而讲闭包时，往往都会和作用域联系到一起，原因很简单，闭包的出现就是受到作用域规则的影响，可以说是因果关系。齐云道长把闭包的前世今生用上中下三部曲来讲述。本期是上部，讲述闭包诞生的前因——作用域。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js修仙" scheme="https://chenshaotang.com/categories/js%E4%BF%AE%E4%BB%99/"/>
    
    
      <category term="js" scheme="https://chenshaotang.com/tags/js/"/>
    
      <category term="作用域闭包" scheme="https://chenshaotang.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JS之函数传参与深浅拷贝原理</title>
    <link href="https://chenshaotang.com/js%E4%BF%AE%E4%BB%99/js%E4%B9%8B%E4%BC%A0%E5%8F%82%E8%A7%84%E5%88%99/"/>
    <id>https://chenshaotang.com/js修仙/js之传参规则/</id>
    <published>2019-01-18T14:35:35.000Z</published>
    <updated>2019-01-20T02:46:15.055Z</updated>
    
    <content type="html"><![CDATA[<p>很多问题看似复杂，没有章法，事实上却有着千丝万缕的联系，陈道长此次阐述因为数据类型不同而引发的问题，本文主要探讨JS函数参数传递规则、浅拷贝、深拷贝的原理。</p><a id="more"></a><h2 id="变量类型和存储"><a href="#变量类型和存储" class="headerlink" title="变量类型和存储"></a>变量类型和存储</h2><p>首先要明确js中变量的特点，<strong>JS变量本身没有类型，只有值有类型</strong>。这句话怎么理解呢，先看下面这段代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">typeof</span> a <span class="comment">//'number'</span></span><br></pre></td></tr></table></figure><p>注意返回的是’number’，不是number，typeof检测的不是a的类型，而是42的类型，也就是a是没有类型的，只有a的值有类型。</p><p>JS总共有7种数据类型：Number、String、Boolean、Null、Symbol、Undefined、Object。Object是引用类型，其他的是基本类型。至于数组和函数属于Object的子类型。不过typeof 一个函数的时候 会返回’function’，这是为了彰显函数是一等公民的地位。它要特殊一点。</p><p>我们在声明一个变量时，会给变量进行赋值，变量在存储的时候也有区别。<strong>基本类型值存放在栈中，可以直接访问。引用类型值存放在堆内存中。</strong>很关键的一点：JS是不允许直接访问内存的，所以当一个变量的值是Object时，它保存的只是一个指针，指向的是Object存放的内存地址。</p><p>定义一个<figure class="highlight plain"><figcaption><span>a </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## JS函数参数</span><br><span class="line"></span><br><span class="line">事实上，参数传递就是受到数据类型的影响。JS的函数有几个特性：1、参数没有个数限制，不管你函数里要用几个，它却可以接收任意多个，因为不用它操心，来的这么些参数都放到了一个参数数组里。另外参数值也没有类型限制，非常的开放，然后函数内再通过arguments对象去访问这个数组，拿到参数，所以参数不跟函数直接打交道，就好比中间有个传话的。**所以这也是为什么es6之前中不能直接给函数参数指定默认值**。</span><br><span class="line"></span><br><span class="line">es6新搞了个rest参数，它搭配了一个数组，变量多余的参数会存放到这个数组里，就不用arguments对象来获取了。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">// arguments变量的写法</span><br><span class="line">function sortNumbers() &#123;</span><br><span class="line">  return Array.prototype.slice.call(arguments).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// rest参数的写法</span><br><span class="line">const sortNumbers = (...numbers) =&gt; numbers.sort();</span><br></pre></td></tr></table></figure></p><h2 id="参数传递问题"><a href="#参数传递问题" class="headerlink" title="参数传递问题"></a>参数传递问题</h2><p>重点来了！<strong>函数参数传递其实就是把函数外的值复制给函数内部的值，也就是按照上面的规则来</strong><br>参数来自外部，要传递到函数里，找个中间变量，<strong>JS是参数是按“值”传递的，这个“值”就是变量的值。当变量的值属于基本类型，这个“值”就是普通值，当变量的值是引用类型时，这个“值”时引用类型的地址。</strong><br>传递的参数值是基本类型值会复制给一个局部变量。传递的参数是引用类型的值，复制的是地址。</p><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>为啥存在浅拷贝和深拷贝，原因和上面一样。当我们想把对象a赋值给变量b，你会发现b和a指向的是一个地方。b改变的时候a也会变。这就是因为变量存储的只是个指针，引用类型的值是放在内存中，没法直接访问。</p><p>普通复制就是浅拷贝，新对象修改时，老对象也会发生变化。<br>但是我们想把b复制给a后，然后两个对象互不干扰，完成这样的复制，这就是深拷贝。</p><p>深拷贝的原理就是把a对象的每个属性的值遍历一遍，然后把它复制给一个中间值，它作为普通的值进行复制到b对象的属性。这就回到了基本变量的复制问题。</p><p>当然一个对象的属性也可能是对象，例如：<code>obj = [{a:1},{b:2}]</code>，我们想把obj赋值给新对象，这个时候就得递归遍历了，把对象中a属性的值1和b属性的值2都给取到，然后把1和2再复制到新的对象里去，这个时候新对象就不会影响到之前的对象了。</p><p>说的有点绕，就是要切断新对象和老对象的关系，但是咱们又没办法直接操作内存，就只能通过引用取到老对象中存的数据值，拿出来之后放到新对象里。这就是深拷贝的思想。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于js中数据类型不同，变量保存的值也有两种存储方式，在堆里面和在栈面，存储方式不同，也就导致了读取方式不同，也就导致了复制操作的结果不同，而参数传递和深浅拷贝都是数据复制的操作。所以两者受到的约束也是相同的，也就要遵循变量读取的规则。</p><p>本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多问题看似复杂，没有章法，事实上却有着千丝万缕的联系，陈道长此次阐述因为数据类型不同而引发的问题，本文主要探讨JS函数参数传递规则、浅拷贝、深拷贝的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="js修仙" scheme="https://chenshaotang.com/categories/js%E4%BF%AE%E4%BB%99/"/>
    
    
      <category term="js" scheme="https://chenshaotang.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS修仙之一界本源</title>
    <link href="https://chenshaotang.com/js%E4%BF%AE%E4%BB%99/js%E4%BF%AE%E4%BB%99%E4%B9%8B%E4%B8%80%E7%95%8C%E6%9C%AC%E6%BA%90/"/>
    <id>https://chenshaotang.com/js修仙/js修仙之一界本源/</id>
    <published>2019-01-16T07:00:42.000Z</published>
    <updated>2019-01-21T03:14:14.688Z</updated>
    
    <content type="html"><![CDATA[<p>齐云先生是中华传统文化的爱好者，也是一位前端开发人员，一直想着如何把工作爱好结合在一块，于是便有了这一篇文章，以咱们中华传统文化《周易》《道德经》里包含的宇宙运行的规律来介绍JS世界是如何被创造的，也是为了能够透过现象看本质，这样才能真正的掌握一门技术。<br><a id="more"></a><br>本文又叫《JS修仙之一界本源》，所谓本源，就是事物最初的样子，JS世界中对象、继承、原型链等等，看似复杂无比，实际上却有规律可循。本文有很多哲学方面的思想，读起来可能会比较晦涩，但是多读几遍，我相信会让你对JS有更清晰的认识。</p><p>自计算机宇宙诞生以来，有很多大神通者在这里开天辟地，开创了很多界，有C、C++、Java等世界，它们彼此相连，其中有一处叫做JavaScript的世界，自被开辟以来吸引了很多修行者来此修炼。JS界由ES、DOM、BOM组成。</p><h2 id="道生一"><a href="#道生一" class="headerlink" title="道生一"></a>道生一</h2><p>话说这一日，齐云道长慕名来到JS界，刚入此界，便被界中三座大山吸引，分别名曰：作用域闭包、原型链继承、异步。相传此三山中藏着js界的创世本源。道长便在此闭关，静心感悟。</p><p>时间一晃就是数月，齐云早已把js界基本情况了解了，不过至于三座大山里隐藏的谜团却迟迟没有头绪。苦闷之中，坐在山上看日出日落，观星辰变化。斗转星移之间，齐云感慨万物变化奇妙，口中念起了老君的《道德经》：道生一，一生二，二生三，三生万物，万物负阴而抱阳。却突然露出了笑容：“怎么没早点想到呢，道衍万物。就是在主宇宙也是生于大道，更何况在这js世界呢”。</p><p>相传当年布兰登十天造此界，应该也是按照这个思路来的。万物都从无产生，此界也是无中生有，0和1是计算机宇宙中的阴阳，界中万物都是由此衍化。再定下八卦五行，此界便可运转繁衍不息。以往大部分人都是从基本的语法开始感悟，今天我从null开始推演。</p><p>了解宇宙本源之后，齐云此时心中有了明悟，仿佛看到了这个世界被创造和不断完善的样子。</p><blockquote><p>虽然js经过几次的升级，拥有更强大的功能，不过最初js只是用来做简单的数据验证。。后来在ECMA-262中定义了ES，才提供了核心语言功能。</p></blockquote><h2 id="开天辟地"><a href="#开天辟地" class="headerlink" title="开天辟地"></a>开天辟地</h2><p>开天辟地是第一步，这个天地就叫引擎。最早只有创始人布兰登在网景时开辟的SpiderMonkey，之后诸神又开辟了几处不同的天地，JScript(IE6,IE7, IE8)、Chakra(IE9,IE10, IE11, IE Edge)、SpiderMonkey(Firefox)、JavaScriptCore(Safari)、V8(Chrome)。不同空间的环境略有不同，但js子民大多可以在这几处天地下都能生存，只不过生活节奏工作效率不一样（引擎性能不同）。更有平行天地Node等。天地既有了，便可以创造万物以及定下此界的规则。万物由代码组成，我们不可能一下子把万物都生成，只需要创造出最基本的元素和种类，之后让他们衍生万物。</p><p><strong>组成代码的五行：变量、操作符、控制语句、对象、函数。</strong><br>变量：不给强制规定类型，可以说是世界最平等的事了，不管你本身什么类型，它都平等对待你，不过麻烦倒也很多。。<br>函数：创造了不少默认的行为规则，toString()、get()、set()就好像人会吃饭睡觉的行为一样，被规定的。</p><blockquote><p>这里只是化用五行，仅仅代表最基本的五种元素，并没有相生相克这些。</p></blockquote><p>基本元素有了，怎么利用这些元素组成无数的代码，这些代码又如何丰富世界呢?只有道衍生的规则能办到，就好像四季更迭，花开花落一般。生与死，对与错。<br>规则之一：语法。它规定了区分大小写、标识符、注释、严格模式、操作符、语句、对象的形式、函数定义。<br>规则之二：数据类型和数据类型的转化，好比水变成冰<br>规则之三：作用域，上下文，闭包。它描述变量存储的规律，细看js修仙之作用域闭包一文<br>规则之四：原型链规则。它是JS界本源之一。有著名的this规则<br>规则之五：异步规则。异步操作是为了改善单线程<br>规则之等等：。。。还有很多规则，例如错误处理等。详看ECMAScript标准</p><p><strong>借助八卦，将js中八种事物融合进来，相互配合，组成运转的JS界。</strong><br><strong>乾代表引擎，坤代表回收机制，震代表构造函数，巽代表引用类型，坎代表执行语句，离代表编译器，艮代表异步，兑代表同步。</strong></p><blockquote><p>乾为天，坤为地，离为太阳，坎为月亮，四卦不停准转有了event loop，有了代码生成编译销毁，事件处理，好比四季循环。之后又有了了震雷，雷动生巽风，雷风相薄，构造函数和引用类型互相影响，艮山兑水，同步异步在event loop中在运转。</p></blockquote><h2 id="三生万物"><a href="#三生万物" class="headerlink" title="三生万物"></a>三生万物</h2><p>和其他OO世界一样，JS也是对象的世界。对象拥有着属性和方法。属性就是特征，方法就是行为。有了这些对象就能动起来了，仿佛拥有了生命一样。我们不可能一下子创造出所有的对象，只有先造出第一批对象，它们是JS对象老祖，负责繁衍教化万民。JS世界对象有自己的特点，它们当中有普通对象和函数对象。函数对象地位较高，属于一等公民，它们可以被调用，还修行一种独特的法术，叫做原型之体。原型之体与函数之体通过<strong>prototype和constructor</strong>相连。本体通过prototype可以获取原型之体的能力，原型之体则通过constructor表明自己函数之体的身份。</p><blockquote><p>虽然typeof function a(){}返回的是’function’不是’object’,这是因为函数确实有一些特殊的属性，因此用typeof来区分函数和其他对象是有必要的</p><p>有人说JS中万物皆对象，事实上是错误的，因为(string、boolean、number、number、undefined)本身不是对象，而是基本类型如a=2。</p></blockquote><p>在每个对象中都存在一块印记,叫[[prototype]]，它是对象的血脉之力，有着惊人的作用，当发动血脉之力时，可以发挥先祖之力，甚至可以使出先天对象的法术。有如此大的威力，主要因为对象的[[prototype]]印记连接的是父辈的原型之体！而父辈之体也有属于自己的血脉之力，因此后辈对象中有遇到自己解决不了的问题时，血脉之力会触发，帮助它们渡过难关。</p><p>有一个特殊的对象Object.prototype，它是这个世界所有对象的智慧之祖，所有的对象都继承了它的智慧。另一个重要的对象是Function.prototyp，它拥有了关于函数对象的智慧，并且它也继承了Object.prototype的智慧。这两个对象我称它们为先天对象，是JS根基对象，它们高高在上，是万象之根。而且它们是Object和Function对象的原型之体，神通广大，原型之体术就是它们最先练就。Function掌管着函数对象，Object掌管着原型之体和普通对象。<strong>几乎所有的函数都是引用类型Function的实例，几乎所有的对象都是Object的实例</strong>Function.prototype继承了Object.prototype（虽然会出现覆盖），Object的血脉又连接Function，可以说这两位是其他JS对象共同的老祖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.__prototype === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="built_in">Object</span>.__prototype === <span class="built_in">Function</span>.prototype</span><br></pre></td></tr></table></figure><blockquote><p>在某对象中找不到要找的属性时，就会沿着原型链网上找。从ECMAScript6开始，[[Prototype]]可以通过Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问，这个等同于JS的非标准但许多浏览器实现的属性<strong>proto</strong></p></blockquote><p>全局的Function对象没有自己的属性和方法，继承于Function.prototype，因此Function.prototype是不能被修改的。Function.prototype还有个特殊的身份，它也是个函数，简直是深藏不露。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype)</span><br><span class="line">[<span class="built_in">Function</span>]</span><br></pre></td></tr></table></figure><p>剩下的一些对象组成了长老会，它们分别是Array、Date、RegExp、String、Math、Error等，以及后面加入的Set、Map等几位长老。长老们拥有各自的神通和家族。例如Array长老擅长操作数组，有sort、slice等神通，而Math长老有random神通。不过它们也都是Object和Fucntion的部下。每个长老的函数之体源自Function，继承了Function.prototype的神通。而它们的原型之体继承了Object.prototype的智慧。</p><p><strong>对象是引用类型的实例</strong>，通过new加构造函数可以创造新对象，后来先天对象Object又感悟了Object.create之法，也可以创造新的对象。</p><blockquote><p>事实上，根本没有构造函数，或者人人都是构造函数。当且仅当使用new时，函数调用会变成构造函数调用。</p></blockquote><p>JS界的老祖，长老会及长老会门下关系如下:</p><p><img src="/js修仙/js修仙之一界本源/JS原型链.png" alt="原型链图"></p><p>可以看到两位老祖高高在上，受万众仰视。它们与多位长老一样，函数体通过蓝色箭头prototype指向原型之体。原型之体通过灰色线constructor连接函数之体,后代子孙而血脉之力由[[prototype]]沿着橙色线，找到了父对象（构造函数）的原型之体，父对象或长老们的原型之体的血脉是绿色的线，指向了Object.prototype。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">duke.__proto__ === Sub.prototype</span><br><span class="line">Sub.prototype.__proto__ = == <span class="built_in">Object</span>.prototype</span><br><span class="line">-------------------------------------------------</span><br><span class="line">Sub.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p>至此，我们可以这么归纳：<br>1.<strong>所有对象都有隐式原型[[prototype]]，它指向了创造它的构造函数的原型对象，一直连接到Object.prototype,而Object.prototype也有隐式原型，而它指向Null</strong>，当访问一个对象的属性找不到时，会沿原型链向上找，找到了会返回，找不到就会继续向上知道null会返回undefined。</p><p>2.<strong>几乎所有函数都是Function的实例，为了符合这个规则，Function的隐式原型指向的是它的原型对象。</strong></p><p>易是包罗万象，一切事物和现象都可以装进这个模式里，易是变化的，不管代码如何复杂，都是符合最基本的规则，易虽然变化，但大道是永恒的，变化之道是不变的。JS的世界也是这样，不管由多复杂的代码组成的程序，也都得遵循最基本的变量声明语法，也要符合原型的设计模式，也都得按照既定的规则来编写。所以，明白这个JS界的一界本源，才能在这里畅游天地之间。</p><p>本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;齐云先生是中华传统文化的爱好者，也是一位前端开发人员，一直想着如何把工作爱好结合在一块，于是便有了这一篇文章，以咱们中华传统文化《周易》《道德经》里包含的宇宙运行的规律来介绍JS世界是如何被创造的，也是为了能够透过现象看本质，这样才能真正的掌握一门技术。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js修仙" scheme="https://chenshaotang.com/categories/js%E4%BF%AE%E4%BB%99/"/>
    
    
      <category term="js" scheme="https://chenshaotang.com/tags/js/"/>
    
      <category term="原型链" scheme="https://chenshaotang.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JS对象属性中get/set与getter/setter是什么</title>
    <link href="https://chenshaotang.com/js%E4%BF%AE%E4%BB%99/js%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7/"/>
    <id>https://chenshaotang.com/js修仙/js之对象属性/</id>
    <published>2019-01-10T15:47:32.000Z</published>
    <updated>2019-01-20T02:46:37.259Z</updated>
    
    <content type="html"><![CDATA[<p>在js属性描述符这部分有几个较难理解的名词概念，本文旨在描述自己对它们的理解，并收录在《齐云札记》里，主要包括:[[Get]]/[[Put]]、get/set、getter/setter几个概念的阐述，数据属性和访问器属性。<br><a id="more"></a></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>首先我们要搞清楚属性的概念，属性是存储在特定命名位置的值，是对象的内容，属性并不直接存储在对象容器内部。属性有两种类型:数据属性和访问器属性。属性具备了属性描述符，用来描述属性拥有的特性。</p><h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>属性描述符用来描述属性特性的(只有在内部才能用的特性),配置属性是否可读，是否可写，是否可枚举，值是多少，读写。</p><p><strong>属性描述符对象</strong><br>Object.definePrOperty(obj,’a’,{value:2,writable:true,configurable:true})第三个参数就是属性描述符对象 ，首先它是个对象，它有自己的属性，其次它是属性a的属性描述符，用来配置属性。</p><p>定义这些特性为了实现JavaScript引擎用的，因此再JavaScript中不能直接访问它们。为了表示特征是内部值，ES规范把它们放在了两对方括号中，例如[[Enumerable]]。</p><blockquote><p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p></blockquote><h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。共有四个描述其行为的特征:</p><ul><li>[[Configurable]]：配置，表示能否删除修改属性的特性，或者把属性修改为访问器属性。默认true</li><li>[[Enumerable]]：枚举，表示能否通过for-in循环返回属性。默认true</li><li>[[Writable]]：可写，表示能否修改属性值。默认true</li><li>[[Value]]：属性的数据值。读写属性值从该位置。默认undefined</li></ul><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>访问器属性不包含数据值；它们包含一对getter和setter函数。共有四个描述其行为的特征:</p><ul><li>[[Configurable]]：配置，表示能否删除修改属性的特性，或者把属性修改为访问器属性。默认true</li><li>[[Enumerable]]：枚举，表示能否通过for-in循环返回属性。默认true</li><li>[[Get]]：在读取属性值时调用的函数。默认undefined</li><li>[[Set]]：在写入属性值时调用的函数。默认undefined</li></ul><p>==当个一个属性定义getter、setter或者两者都有时，这个属性就成了访问器属性==</p><p>知道属性分类之后，下面我们逐一解答开头的几个问题：</p><h1 id="Get-Put-是什么"><a href="#Get-Put-是什么" class="headerlink" title="[[Get]]/[[Put]]是什么"></a>[[Get]]/[[Put]]是什么</h1><p>首先要明确一点，[[Get]]和[[Put]]是对象默认的内置操作，可以理解为算法函数。它是在访问属性时的操作，例如通过obj.a访问a属性时就是实现了[[Get]]操作，它会先找到相同的属性名，找到才要返回属性值。<br>没有找到就会按照[[Get]]算法的设计，沿着原型链找，找不到会返回undefined。<br>[[Put]]被触发时，取决于许多因素，最重要的有对象中是否已经存在这个属性。如果已经存在，算法大致会检查下面这些内容：</p><p>1.属性是否是访问描述符？如果是并且存在setter就调用setter<br>2.属性的数据描述符中writable是否是false？如果是，在非严格模式下静默失败，在严格模式下抛出TypeError异常。<br>3.如果都不是，将该值设置为属性的值。</p><h1 id="get-set和getter-setter"><a href="#get-set和getter-setter" class="headerlink" title="get/set和getter/setter"></a>get/set和getter/setter</h1><p>[[Get]]和[[Set]]：当属性拥有这两个特性时，属性就是访问器属性。代表着在访问属性或者写入属性值时，对返回值做附加的操作。而这个<strong>操作就是getter/setter函数</strong>。<br>它们只能应用到单个属性上，无法应用在整个对象上。getter/setter是隐藏函数，是访问器属性默认拥有的隐藏函数。在读取访问器属性时调用getter，返回有效的值；在写入访问器属性时调用setter函数并传入新值。</p><p>不管是对象文字语法中的get a(){…}，还是的defineProperty(..)中的显式定义，二者都会在对象中创造一个不包含值得属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当做属性访问的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="comment">//给a定义一个getter</span></span><br><span class="line">    get a()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">     &#125;,</span><br><span class="line"><span class="comment">//给a定义一个setter</span></span><br><span class="line">    set a(val)&#123;</span><br><span class="line">      <span class="keyword">this</span>._a_=val *<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.a=<span class="number">2</span>;</span><br><span class="line">myObject.a;<span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>==设置getter会覆盖默认的[[Get]]操作，setter会覆盖默认得[[Put]],也被称为赋值操作==</p><blockquote><p>实际上我们赋值([[Put]])操作中的值2存储到了另一个变量_a_中。名称_a_只是一种惯例，没有任何特殊行为。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>属性是拥有自己的特性的，主要用来描述属性是否可以进行修改枚举配置的。我们访问对象的属性时就是[[Get]]操作，写入就是[[Put]]，根据算法找到对应的属性。如果要对属性值进行附加操作时，就需要设置get/set特性，此时属性也就会变成访问器属性，然后调用默认的隐藏的getter/setter函数对属性进行操作。然后返回属性值。</p><p>本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在js属性描述符这部分有几个较难理解的名词概念，本文旨在描述自己对它们的理解，并收录在《齐云札记》里，主要包括:[[Get]]/[[Put]]、get/set、getter/setter几个概念的阐述，数据属性和访问器属性。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js修仙" scheme="https://chenshaotang.com/categories/js%E4%BF%AE%E4%BB%99/"/>
    
    
      <category term="js" scheme="https://chenshaotang.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue之electron打包</title>
    <link href="https://chenshaotang.com/vue/vue%E4%B9%8Belectron/"/>
    <id>https://chenshaotang.com/vue/vue之electron/</id>
    <published>2018-12-29T06:06:53.000Z</published>
    <updated>2019-01-18T12:02:13.736Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了使用electron-vue对vue项目进行打包的处理办法。工欲善其事,必先利其器,在使用electron-vue打包客户端之前,我们需要进行相关的环境配置。<br><a id="more"></a></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>需要管理员权限的powershell,外加翻墙,否则很多下载都不成功,关掉杀毒软件</p><ul><li>安装node,vue-cli</li><li>安装windows-build-tools</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init simulatedgreg/electron-vue my-project</span><br></pre></td></tr></table></figure><p>在项目初始化过程中会让选择electron-builder或者electron-packager,这是electron打包的两种方式。下面我们会分别介绍两种方式异同。</p><blockquote><p>再生成的项目中\src下有main和renderer,其中main为主进程,配置菜单界面大小等,renderer为渲染进程,页面组件在这里配置</p></blockquote><p>结构图如下：<br><img src="/vue/vue之electron/jie.jpg" alt="结构图"><br>无论是选择的packager,还是builder,在生成项目之后,都要执行以下操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> project</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="electron-builder打包过程"><a href="#electron-builder打包过程" class="headerlink" title="electron-builder打包过程"></a>electron-builder打包过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>执行该命令后会下载打包所需要的依赖文件,例如electron-vX.X.X-win32-x64.zip,但通常会出现下载失败,我们可以手动下载,放到指定的目录下。</p><blockquote><p>解决办法就是根据控制台显示的错误信息,到npm去搜索该文件,下载下来。通常放在C:\Users\Administrator\AppData\Local\electron\Cache</p></blockquote><p>解决了出现的问题之后继续执行npm run build,如果继续出现错误,仍然按照上述办法解决。<br>另外有两个必装的依赖:winCodeSign和nsis</p><blockquote><p><a href="https://github.com/electron-userland/electron-builder-binaries/releases" target="_blank" rel="noopener">wincodesin包地址</a><br><a href="https://github.com/electron-userland/electron-builder-binaries/releases/tag/nsis-resources-3.0.0" target="_blank" rel="noopener">nsis包地址</a></p></blockquote><p>将下载的依赖解压到C:\Users\Administrator\AppData\Local\electron\Cache</p><p>之后就可以顺利打包了</p><h2 id="electron-packer打包过程"><a href="#electron-packer打包过程" class="headerlink" title="electron-packer打包过程"></a>electron-packer打包过程</h2><p>使用packager打包只能生成可执行版,通过下面指令生成相对的客户端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm run build:win32</span><br><span class="line">npm run build:darwin</span><br><span class="line">npm run build:linux</span><br><span class="line">npm run build:mas</span><br></pre></td></tr></table></figure><p>本文是陈少棠原创，收录在《齐云札记》，转载请标明原作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了使用electron-vue对vue项目进行打包的处理办法。工欲善其事,必先利其器,在使用electron-vue打包客户端之前,我们需要进行相关的环境配置。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="https://chenshaotang.com/categories/vue/"/>
    
    
      <category term="electron" scheme="https://chenshaotang.com/tags/electron/"/>
    
  </entry>
  
</feed>
